# --- METADATA ---
name = "OutlineAgent"
description = "Transforms refined goals into a high-quality slide outline consisting of 6–12 concise titles."
author = "Google ADK Example"
license = "Apache 2.0"
version = "1.0.0"
homepage = "https://github.com/google/agent-development-kit"
# --- END METADATA ---

import json
import re
from typing import List, Optional, Dict
from pydantic import BaseModel, Field
from .base import BaseAgent, AgentResult


class Input(BaseModel):
    """
    Defines the input parameters for the OutlineAgent.
    """
    clarifiedContent: str = Field(
        description="A clear, refined statement of the presentation's goals and key messages."
    )
    constraints: Optional[Dict] = Field(
        default=None,
        description="Optional constraints to guide the outline generation, e.g., {'max_slides': 10}."
    )


class Output(BaseModel):
    """
    Defines the structured output generated by the OutlineAgent.
    """
    outline: List[str] = Field(
        description="An ordered list of 6-12 concise slide titles that form the presentation's structure."
    )


class Agent(BaseAgent):
    """
    An agent that generates a structured slide outline from a set of clarified goals.
    """

    def run(self, data: Input) -> AgentResult:
        """
        Executes the agent's logic to generate a slide outline.

        Args:
            data: An instance of the Input model containing the presentation's goals.

        Returns:
            An AgentResult containing the generated outline and LLM usage statistics.
        """
        system_prompt = (
            "You are an expert presentation outliner. Your task is to transform the user's refined goals "
            "into a logical and compelling slide outline. The outline should consist of 6 to 12 short, "
            "specific, and action-oriented titles. You must return the outline as a single, valid JSON array of strings."
        )

        prompt_messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": f"Here are the refined goals for the presentation:\n{data.clarifiedContent}"},
        ]
        
        if data.constraints:
            prompt_messages.append({"role": "user", "content": f"Please adhere to the following constraints:\n{json.dumps(data.constraints)}"})

        prompt_messages.append({"role": "user", "content": "Return only the valid JSON array and nothing else."})

        # Call the language model.
        text, usage = self.llm(prompt_messages)

        outline = self._parse_outline(text)

        output_data = Output(outline=outline)

        return AgentResult(data=output_data.model_dump(), usage=usage)

    def _parse_outline(self, text: str) -> List[str]:
        """
        Parses the model's output, attempting to decode JSON and falling back to a line-based parser.
        """
        try:
            # Clean the text in case the LLM wraps it in markdown code blocks.
            cleaned_text = text.strip().removeprefix("```json").removesuffix("```")
            parsed_json = json.loads(cleaned_text)
            
            # Basic validation to ensure the parsed JSON is a list of strings.
            if isinstance(parsed_json, list) and all(isinstance(item, str) for item in parsed_json):
                return parsed_json[:12]  # Enforce max length
            else:
                # The structure is valid JSON but not what we expect.
                raise ValueError("Parsed JSON is not a list of strings.")
        except (json.JSONDecodeError, ValueError):
            # Fallback for non-JSON or malformed output: parse as a bulleted/numbered list.
            lines = text.split('\n')
            outline = []
            for line in lines:
                # Remove common list prefixes (e.g., "1. ", "- ", "* ")
                cleaned_line = re.sub(r'^\s*[\d\.\-\*\•]+\s*', '', line).strip()
                if cleaned_line:
                    outline.append(cleaned_line)
            return outline[:12] # Enforce max length